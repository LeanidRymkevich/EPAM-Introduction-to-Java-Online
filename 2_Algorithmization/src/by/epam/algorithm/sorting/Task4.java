package by.epam.javaonline.algorithm.sorting;

import java.util.Arrays;

/* Сортировка обменами. Дана последовательность чисел a(1) <= a(2) <=...<= a(n).
 * Требуется переставить числа в порядке возрастания. Для этого сравниваются два
 * соседних числа a(i) и a(i + 1). Если a(i) > a(i + 1) , то делается перестановка.
 * Так продолжается до тех пор, пока все элементы не станут расположены в порядке возрастания.
 * Составить алгоритм сортировки, подсчитывая при этом количества перестановок
*/

public class Task4 {

	public static void main(String[] args) {
		
		// значения исходного массива в разнобой т.к. если делать согласно заданию
		// нет смысла в сортировке т.к. a(1) <= a(2) <=...<= a(n) это и есть
		// 'в порядке возрастания'
		int[] a = {4, 11, -4, 6, 9, 13, -8}; 
		
		System.out.printf("Исходный массив a[%d] = %s.\n", a.length, Arrays.toString(a));
		
		int counter = 0; // счетчик замен
		boolean isSort; // отсортирован ли уже массив?
		
		// уменьшаем i каждый раз на 1 т.к. после каждого прохода внутреннего
		// цикла максимальный элемент ставится в конец массива
		for(int i = a.length - 1; i > 0; i--) { 
			
			isSort = true; // предполагаем что да
			
			for(int j = 0; j < i; j++) { 
				
				if(a[j] > a[j+1]) { // если поменять на '>' на '<' то будет сортировка по убыванию
					
					int temp = a[j];
					a[j] = a[j+1];
					a[j+1] = temp;
					counter++;
					isSort = false; // раз нужна была замена значит массив не был до этого отсортирован
				}
			}
			
			if(isSort) { // если отсортирован нет смысла дальше проходить цикл
				break;
			}
			
		}
		
		System.out.printf("Отсортированный массив MinToMax[%d] = %s.\n", a.length, Arrays.toString(a));
		System.out.printf("Колличество перестановок: %d.", counter);
	}

}
